<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
        A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá,
        hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy
        példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell
        az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
        https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf (16-22 fólia)
        Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/theefues/prog2/blob/master/Arroway/Polargen.java">https://github.com/theefues/prog2/blob/master/Arroway/Polargen.java</link>        
        </para>
        <programlisting language='java'><![CDATA[
import java.util.Random;
import java.io.*;
import java.lang.Math;

public class PolarGen	{

  public final  static int RAND_MAX = 32767;
  private static boolean bExists;
  private double dValue;
  static Random cRandomGenerator = new Random();
  

  public PolarGen() { 			//a konstruktor kifejtése
	bExists = false;
	cRandomGenerator.setSeed(20); 	//random inicializálás
  };
  
  public double PolarGet()	{
    	if (!bExists)
  {
		double u1, u2, v1, v2, w;

		do{
			u1 = cRandomGenerator.nextInt (RAND_MAX) / (RAND_MAX + 1.0); //innentől jön az algoritmus
			u2 = cRandomGenerator.nextInt (RAND_MAX) / (RAND_MAX + 1.0);
			v1 = 2 * u1 - 1;
			v2 = 2 * u2 - 1;
			w = v1 * v1 + v2 * v2;
		    }
		while (w > 1);

		double r = Math.sqrt ((-2 * Math.log (w)) / w);

		dValue = r * v2; 
		bExists = !bExists;

		return r * v1; //idáig tart az algoritmus
	}
	
	else
	{
		bExists = !bExists; //ha van korábbi random érték, akkor azt adja vissza
		return dValue;
	}
  };    
  
  public static void main(String args[])	{
    PolarGen cPolarGen = new PolarGen();
    double  dEredmeny = cPolarGen.PolarGet();
    System.out.println(dEredmeny);
  }
  
}]]></programlisting>
        <para>
Ha van tárolt érték, adja vissza azt. Ha nincs, csinálja meg. Generálunk 2 random számot -1 és 1 között,
abból pedig elveszünk egyet. Majd vesszük a kettő négyzetösszegét. Ezt addig csináljuk, amíg s nagyobb egyenlő mint 1 vagy egyenlő 0-val.
Ez után felvesszük a multiplier változót, ami az s -2szeres logaritmus hányadosának a négyzetgyöke. A
v2-ot megszorozzuk vele, ez lesz a tárolt érték. Majd kiadjuk, hogy van tárolt érték és visszaadjuk a v1 * multiplier eredményét.
        </para>
        <para>
            Majdnem ugyanezt a kódot találjuk a JDK sourcekódjában is.
        </para>
        <para>
            Ugyanez a normálist visszaadó program C++-ban így néz ki:
        </para>
                <programlisting language='java'><![CDATA[
#include polargen.h
double
PolarGen::kovetkezo ()
{
  if (nincsTarolt)
    {
      double u1, u2, v1, v2, w;
      do
	{
	  u1 = std::rand () / (RAND_MAX + 1.0);
	  u2 = std::rand () / (RAND_MAX + 1.0);
	  v1 = 2 * u1 - 1;
	  v2 = 2 * u2 - 1;
	  w = v1 * v1 + v2 * v2;
	}
      while (w > 1);

      double r = std::sqrt ((-2 * std::log (w)) / w);

      tarolt = r * v2;
      nincsTarolt = !nincsTarolt;

      return r * v1;
    }
  else
    {
      nincsTarolt = !nincsTarolt;
      return tarolt;
    }
}]]></programlisting>
<para>A polargen.h headerben deklaráljuk a következő értékeket, többek között itt vesszük fel a polargen osztályunkat is:</para>
        <programlisting language='java'><![CDATA[#ifndef POLARGEN__H
#define POLARGEN__H

#include <cstdlib>
#include <cmath>
#include <ctime>

class PolarGen
{
public:
  PolarGen ()
  {
    nincsTarolt = true;
    std::srand (std::time (NULL));
  }
   ~PolarGen ()
  {
  }
  double kovetkezo ();

private:
  bool nincsTarolt;
  double tarolt;

};

#endif]]></programlisting>

    </section>        

    <section>
        <title>„Gagyi”</title>
        <para>
Az ismert formális
„<![CDATA[
while (x <= t && x >= t && t != x);
]]>” tesztkérdéstípusra adj a szokásosnál
(miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
értékekkel meg nem! A példát építsd a JDK Integer.java forrására
, hogy a 128-nál inkluzív objektum
példányokat poolozza!
</para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/theefues/prog2/blob/master/Arroway/Gagyi.java">https://github.com/theefues/prog2/blob/master/Arroway/Gagyi.java</link>             
        </para>
                <programlisting language='java'><![CDATA[
import java.lang.Number;
class Gagyi {
        public static void main (String[] args) {
        Integer x = 300;
        Integer t = 300;
        while (x <= t && x >= t && t != x)
            System.out.println("infinity");
        }

}]]></programlisting>
                <programlisting language='java'><![CDATA[
import java.lang.Number;
class Gagyi {
        public static void main (String[] args) {
        Integer x = 127;
        Integer t = 127;
        while (x <= t && x >= t && t != x)
            System.out.println("nem infinity");
        }

}]]></programlisting>

        <para>
            A while ciklusban deklarált formális értékei, amennyiben 127-nél nagyobb értéket vesznek fel, végtelen ciklusba lép be. Az importált
            könyvtár a JDK Number könyvtárából veszi az x és a t értékét, ezzel magyarázható a jelenség, mivel az itt jelenlévő Integer csak -128 és 127 közötti értékekkel operál, ezért ha ebből a tartományból választunk értéket, egy létező objektumra kapunk referenciát, ezért
            nem teljesül a feltétel.
        </para>
        
    </section>  

    <section>
        <title>Yoda</title>
        <para>
        Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda
        conditions-t! https://en.wikipedia.org/wiki/Yoda_conditions
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/theefues/prog2/blob/master/Arroway/Yoda.java">https://github.com/theefues/prog2/blob/master/Arroway/Yoda.java</link>        
        </para>
        <para>
            A Yoda Conditions lényege, hogy ellentétben a hagyományos összehasonlítással - ahol a változót hasonlítjuk az adott értékhez - felcserélve történik a művelet. Tehát adott a következő állítás:
        </para>
        <programlisting language='java'><![CDATA[if( értékVáltozó == 10) {/*...*/}]]></programlisting>
        <para>Ez a hagyományos eljárás. Ugyanez Yoda Conditions környezetben:</para>
        <programlisting language='java'><![CDATA[if( 10 == értékVáltozó) {/*...*/}]]></programlisting>
        <para>Mindkét esetben hasonló eredményeket kapunk. Azonban illik vigyázni, hiszen a legtöbb nyelvben az összehasonlító operátor a dupla egyenlőségjel (==), amit sokszor összekevernek az értékadó operátorral,
        ami az egyedüli egyenlőségjel (=).</para>
        <para>A feladat szerint egy olyan Java programoz kell írnunk, ami leáll java.lang.NullPointerEx hibával, amennyiben nem követjük az utóbbi feltételt:</para>
        <programlisting language='java'><![CDATA[
public class Yoda {
    public static void main(String[] args) {
      String text = null;
      if ("Text".equals(text))
      System.out.println("Text".equals(text));
      if (text.equals("Text"))
      System.out.println("Text".equals(text));
    }
}]]></programlisting>
<para>A fenti programot lefuttatva a 6. sorban, tehát a második if-nél hibát dob ki, pontosan azt, amit akartunk. Ha egy adott értéket, jelen esetben a Text stringet hasonlítjuk a text változónkhoz,
nem kapunk kivételt. Viszont ha fordítva csináljuk, és a text változónkat, ami jelen esetben null "értékkel" rendelkezik hasonlítjuk a Text értékhez, hibát kapunk, mivel ha valaminek van értéke,
az már alapból nem lehet null.</para>
        
    </section>  
    <section>
        <title>Kódolás from scratch</title>
        <para>
Induljunk ki ebből a tudományos közleményből: http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbpalg.pdf és csak ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus megvalósítását!
Ha megakadsz, de csak végső esetben: https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitokjavat/apbs02.html#pi_jegyei (mert ha csak lemásolod, akkor pont az a fejlesztői élmény marad ki,
melyet szeretném, ha átélnél).
</para>

        <para>
        Megoldás forrása: <link xlink:href="https://github.com/theefues/prog2/blob/master/Arroway/PiBBP.java">https://github.com/theefues/prog2/blob/master/Arroway/PiBBP.java</link>        
               
        </para>
        <para>
            A következő program kiszámolja nekünk, hogy mennyi a pi értéke hexadecimális kifejtésben, amely azért jó, mert képesek vagyunk úgy meghatározni egy helyről a pi értékeit,
            hogy tudnánk az előtte levő számokat. Ez az eljárás egyáltalán nem újkeletű: 1995-ben talált Bailey-Borwein-Plouffe féle algoritmust alkalmazva könnyen meghatározható.
        </para>
                <programlisting language='java'><![CDATA[public class PiBBP {
    public PiBBP(int d) { // ez a funkció számolja ki a hexadecimális értéket
        String d16PiHexaJegyek; // ez a változó fogja tárolni a kapott értéket
        double d16Pi = 0.0d;
        
        double d16S1t = d16Sj(d, 1);
        double d16S4t = d16Sj(d, 4);
        double d16S5t = d16Sj(d, 5);
        double d16S6t = d16Sj(d, 6);
        
        d16Pi = 4.0d*d16S1t - 2.0d*d16S4t - d16S5t - d16S6t;
        
        d16Pi = d16Pi - StrictMath.floor(d16Pi);
        
        StringBuffer sb = new StringBuffer();
        
        Character hexaJegyek[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        
        while(d16Pi != 0.0d) {
            
            int jegy = (int)StrictMath.floor(16.0d*d16Pi);
            
            if(jegy<10)
                sb.append(jegy);
            else
                sb.append(hexaJegyek[jegy-10]);
            
            d16Pi = (16.0d*d16Pi) - StrictMath.floor(16.0d*d16Pi);
        }
        
        d16PiHexaJegyek = sb.toString();
    }
    public double d16Sj(int d, int j) {
        
        double d16Sj = 0.0d;
        
        for(int k=0; k<=d; ++k)
            d16Sj += (double)n16modk(d-k, 8*k + j) / (double)(8*k + j);
        
        return d16Sj - StrictMath.floor(d16Sj);
    }

    public long n16modk(int n, int k) {
        
        int t = 1;
        while(t <= n)
            t *= 2;
        
        long r = 1;
        
        while(true) {
            
            if(n >= t) {
                r = (16*r) % k;
                n = n - t;
            }
            
            t = t/2;
            
            if(t < 1)
                break;
            
            r = (r*r) % k;
            
        }
        
        return r;
    }
   
    public String toString() {
        
        return d16PiHexaJegyek;
    }
    public static void main(String args[]) {        
        System.out.print(new PiBBP(1000000));
    }
}
]]></programlisting>
<para>A programunk visszaadja a pi értéket a d+1 helyről számítva, azaz a jelen esetben a 1000001. helyről, amely egész pontosan a 6C65E5308. A C nyelv long double változóit használva sokkal pontosabb 
értékeket is képesek lehetünk meghatározni. De a Java PiBBP osztály segítségével előröl is kezdhetjük számolni a pi értékét, ha a main függvényt a következőre módosítjuk:
</para>
        <programlisting language='java'><![CDATA[   public static void main(String args[]) {
        
        for(int i=0; i<3000; i+=1) {
            PiBBP piBBP = new PiBBP(i);
            System.out.print(piBBP.toString().charAt(0));
        }
    }]]></programlisting>
    <para>Ezt alkalmazva megkapjuk a pi első 3000 jegyét hexadecimális értékben.</para>


    </section>  	
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
